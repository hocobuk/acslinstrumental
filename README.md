# acslinstrumental
# Инструментальное средство статического анализа ACSL-спецификаций

### Входные данные
Утилита получает на вход путь к папке с проектом. Проект содержит файлы с исходным кодом на языке Си, то есть с расширением `.c` или `.h`. Файлы могут быть вложены в папки, то есть поиск таких файлов необходимо производить рекурсивно. Эти файлы содержат ACSL-спецификации в комментариях особого вида.

### Ожидаемое поведение утилиты
В папке `sample-project` находится пример проекта, который должна анализировать разрабатываемая утилита. В файле `acsl.c` находится определение предикатов:
```c
/*@ axiomatic Security {
    predicate isCharDevice(struct inode* i) =
      S_ISCHR(i->i_mode);
    predicate validInode(struct inode * i) =
      \valid(i) &&
      \valid(getInodeSecurity(i));
}*/
```
В файле `main.c` находятся спецификации для функции `f`:
```c
/*@ requires S_ISCHR(inode->i_mode);
    requires \valid(getInodeSecurity(inode)) && \valid(inode);
    assigns \nothing;
*/
int f(struct inode *inode);
```
Эти спецификации можно переработать, используя уже определённые предикаты `isCharDevice` и `validInode`; утилита должна указать на конструкции `S_ISCHR(inode->i_mode)` и `\valid(getInodeSecurity(inode)) && \valid(inode)`. Обратите внимание, что в спецификациях функции `f` условия `\valid(getInodeSecurity(inode))` и `\valid(inode)` находятся не в том же порядке, что в определении предиката `validInode`. Утилита должна корректно обрабатывать этот случай, то есть учитывать коммутативность конъюнкции. Также необходимо обрабатывать случай логических функций (которые задаются с помощью ключевого слова `logic`).

### Формат вывода
Для каждого случая возможной замены конструкции на ACSL-предикат или логическую функцию утилита должна выводить сообщение следующего вида:
```
Может быть использован предикат `isSocketFilesystem`:
 --> src/main.c:4:5
  |
4 | requires superblockMagicNumber(d, i) == SOCKFS_MAGIC;
  |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


```
Здесь:
- `src/main.c` - путь к файлу, в котором может быть произведена замена, относительно корневой папки проекта.
- 4 - номер строки в файле. Нумерация строк начинается с единицы.
- 5 - номер символа в строке. Нумерация символов начинаетс с единицы.
- `isSocketFilesystem` - название предиката, который может быть использован для замены конструкции.

Конструкция, которая может быть заменена (в примере это `superblockMagicNumber(d, i) == SOCKFS_MAGIC`), должна быть выделена с помощью символов `^`.


## Установка

1. Клонируйте репозиторий.
2. Установите зависимости: pyparsing

## Использование

Запустите скрипт main.py для начала работы.

### Пример использования разрабатываемой утилиты
```bash
python3 search_acsl.py /project-path
```
Здесь `search_acsl.py ` - название утилиты, а `~/project-path` - путь к папке с проектом.
